/**
 * Copyright 2011 Google Inc.
 * Copyright 2014 Andreas Schildbach
 * Copyright 2015 Marclass
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bruteForcer;


import com.google.common.io.BaseEncoding;

import org.bouncycastle.crypto.digests.RIPEMD160Digest;


import java.io.IOException;

import java.io.OutputStream;
import java.math.BigInteger;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;

import java.util.concurrent.BlockingQueue;



/**
 * A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 * To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 */
public class Utils {
	private static final MessageDigest digest;
	static {
		try {
			digest = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);  // Can't happen.
		}
	}
	
	private final MessageDigest digest2;
	
	public Utils() throws NoSuchAlgorithmException{
		digest2 = MessageDigest.getInstance("SHA-256");
	}
	
	private static BlockingQueue<Boolean> mockSleepQueue;

	/**
	 * The regular {@link java.math.BigInteger#toByteArray()} method isn't quite what we often need: it appends a
	 * leading zero to indicate that the number is positive and may need padding.
	 *
	 * @param b the integer to format into a byte array
	 * @param numBytes the desired size of the resulting byte array
	 * @return numBytes byte long array.
	 */
	public static byte[] bigIntegerToBytes(BigInteger b, int numBytes) {
		if (b == null) {
			return null;
		}
		byte[] bytes = new byte[numBytes];
		byte[] biBytes = b.toByteArray();
		int start = (biBytes.length == numBytes + 1) ? 1 : 0;
		int length = Math.min(biBytes.length, numBytes);
		System.arraycopy(biBytes, start, bytes, numBytes - length, length);
		return bytes;        
	}

	public static void uint32ToByteArrayBE(long val, byte[] out, int offset) {
		out[offset + 0] = (byte) (0xFF & (val >> 24));
		out[offset + 1] = (byte) (0xFF & (val >> 16));
		out[offset + 2] = (byte) (0xFF & (val >> 8));
		out[offset + 3] = (byte) (0xFF & (val >> 0));
	}

	public static void uint32ToByteArrayLE(long val, byte[] out, int offset) {
		out[offset + 0] = (byte) (0xFF & (val >> 0));
		out[offset + 1] = (byte) (0xFF & (val >> 8));
		out[offset + 2] = (byte) (0xFF & (val >> 16));
		out[offset + 3] = (byte) (0xFF & (val >> 24));
	}

	public static void uint64ToByteArrayLE(long val, byte[] out, int offset) {
		out[offset + 0] = (byte) (0xFF & (val >> 0));
		out[offset + 1] = (byte) (0xFF & (val >> 8));
		out[offset + 2] = (byte) (0xFF & (val >> 16));
		out[offset + 3] = (byte) (0xFF & (val >> 24));
		out[offset + 4] = (byte) (0xFF & (val >> 32));
		out[offset + 5] = (byte) (0xFF & (val >> 40));
		out[offset + 6] = (byte) (0xFF & (val >> 48));
		out[offset + 7] = (byte) (0xFF & (val >> 56));
	}

	public static void uint32ToByteStreamLE(long val, OutputStream stream) throws IOException {
		stream.write((int) (0xFF & (val >> 0)));
		stream.write((int) (0xFF & (val >> 8)));
		stream.write((int) (0xFF & (val >> 16)));
		stream.write((int) (0xFF & (val >> 24)));
	}

	public static void int64ToByteStreamLE(long val, OutputStream stream) throws IOException {
		stream.write((int) (0xFF & (val >> 0)));
		stream.write((int) (0xFF & (val >> 8)));
		stream.write((int) (0xFF & (val >> 16)));
		stream.write((int) (0xFF & (val >> 24)));
		stream.write((int) (0xFF & (val >> 32)));
		stream.write((int) (0xFF & (val >> 40)));
		stream.write((int) (0xFF & (val >> 48)));
		stream.write((int) (0xFF & (val >> 56)));
	}

	public static void uint64ToByteStreamLE(BigInteger val, OutputStream stream) throws IOException {
		byte[] bytes = val.toByteArray();
		if (bytes.length > 8) {
			throw new RuntimeException("Input too large to encode into a uint64");
		}
		bytes = reverseBytes(bytes);
		stream.write(bytes);
		if (bytes.length < 8) {
			for (int i = 0; i < 8 - bytes.length; i++)
				stream.write(0);
		}
	}

	/**
	 * See {@link Utils#doubleDigest(byte[], int, int)}.
	 */
	public static byte[] doubleDigest(byte[] input) {
		return doubleDigest(input, 0, input.length);
	}

	public byte[] doubleDigest2(byte[] input){
		return doubleDigest2(input, 0, input.length);
	}
	
	public  byte[] doubleDigest2(byte[] input, int offset, int length) {
		//synchronized (digest) {
			digest2.reset();
			digest2.update(input, offset, length);
			byte[] first = digest2.digest();
			return digest2.digest(first);
		//}
	}
	
	
	/**
	 * Calculates the SHA-256 hash of the given byte range, and then hashes the resulting hash again. This is
	 * standard procedure in Bitcoin. The resulting hash is in big endian form.
	 */
	public static byte[] doubleDigest(byte[] input, int offset, int length) {
		synchronized (digest) {
			digest.reset();
			digest.update(input, offset, length);
			byte[] first = digest.digest();
			return digest.digest(first);
		}
	}

	public static byte[] singleDigest(byte[] input, int offset, int length) {
		synchronized (digest) {
			digest.reset();
			digest.update(input, offset, length);
			return digest.digest();
		}
	}

	/**
	 * Calculates SHA256(SHA256(byte range 1 + byte range 2)).
	 */
	public static byte[] doubleDigestTwoBuffers(byte[] input1, int offset1, int length1,
			byte[] input2, int offset2, int length2) {
		synchronized (digest) {
			digest.reset();
			digest.update(input1, offset1, length1);
			digest.update(input2, offset2, length2);
			byte[] first = digest.digest();
			return digest.digest(first);
		}
	}

	

	/**
	 * Hex encoding used throughout the framework. Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
	 */
	public static final BaseEncoding HEX = BaseEncoding.base16().lowerCase();

	/**
	 * Returns a copy of the given byte array in reverse order.
	 */
	public static byte[] reverseBytes(byte[] bytes) {
		// We could use the XOR trick here but it's easier to understand if we don't. If we find this is really a
		// performance issue the matter can be revisited.
		byte[] buf = new byte[bytes.length];
		for (int i = 0; i < bytes.length; i++)
			buf[i] = bytes[bytes.length - 1 - i];
		return buf;
	}

	

	

	/**
	 * Calculates RIPEMD160(SHA256(input)). This is used in Address calculations.
	 */
	 public static byte[] sha256hash160(byte[] input) {
		try {
			byte[] sha256 = MessageDigest.getInstance("SHA-256").digest(input);
			RIPEMD160Digest digest = new RIPEMD160Digest();
			digest.update(sha256, 0, sha256.length);
			byte[] out = new byte[20];
			digest.doFinal(out, 0);
			return out;
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);  // Cannot happen.
		}
	 }

	

	 

	 /**
	  * If non-null, overrides the return value of now().
	  */
	 public static volatile Date mockTime;

	
	 public static Date now() {
		 if (mockTime != null)
			 return mockTime;
		 else
			 return new Date();
	 }

	 // TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
	 /** Returns the current time in milliseconds since the epoch, or a mocked out equivalent. */
	 public static long currentTimeMillis() {
		 if (mockTime != null)
			 return mockTime.getTime();
		 else
			 return System.currentTimeMillis();
	 }

	 public static long currentTimeSeconds() {
		 return currentTimeMillis() / 1000;
	 }

	 private static final TimeZone UTC = TimeZone.getTimeZone("UTC");

	 /**
	  * Formats a given date+time value to an ISO 8601 string.
	  * @param dateTime value to format, as a Date
	  */
	 public static String dateTimeFormat(Date dateTime) {
		 DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
		 iso8601.setTimeZone(UTC);
		 return iso8601.format(dateTime);
	 }

	 /**
	  * Formats a given date+time value to an ISO 8601 string.
	  * @param dateTime value to format, unix time (ms)
	  */
	 public static String dateTimeFormat(long dateTime) {
		 DateFormat iso8601 = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
		 iso8601.setTimeZone(UTC);
		 return iso8601.format(dateTime);
	 }

	 public static byte[] copyOf(byte[] in, int length) {
		 byte[] out = new byte[length];
		 System.arraycopy(in, 0, out, 0, Math.min(length, in.length));
		 return out;
	 }

	 /**
	  * Creates a copy of bytes and appends b to the end of it
	  */
	 public static byte[] appendByte(byte[] bytes, byte b) {
		 byte[] result = Arrays.copyOf(bytes, bytes.length + 1);
		 result[result.length - 1] = b;
		 return result;
	 }

	 /**
	  * Attempts to parse the given string as arbitrary-length hex or base58 and then return the results, or null if
	  * neither parse was successful.
	  */
	 public static byte[] parseAsHexOrBase58(String data) {
		 try {
			 return HEX.decode(data);
		 } catch (Exception e) {
			 // Didn't decode as hex, try base58.
			 try {
				 return Base58.decodeChecked(data);
			 } catch (AddressFormatException e1) {
				 return null;
			 }
		 }
	 }

	 public static boolean isWindows() {
		 return System.getProperty("os.name").toLowerCase().contains("win");
	 }

	 

	 // 00000001, 00000010, 00000100, 00001000, ...
	 private static final int bitMask[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

	 



	 

	
}
